Delivered-To: joelvanderwerf@gmail.com
Received: by 10.220.71.202 with SMTP id i10csp23887vcj;
        Thu, 10 Apr 2014 06:01:35 -0700 (PDT)
Return-Path: <alexander.thomson@gmail.com>
Received-SPF: pass (google.com: domain of alexander.thomson@gmail.com designates 10.182.85.193 as permitted sender) client-ip=10.182.85.193
Authentication-Results: mr.google.com;
       spf=pass (google.com: domain of alexander.thomson@gmail.com designates 10.182.85.193 as permitted sender) smtp.mail=alexander.thomson@gmail.com;
       dkim=pass header.i=@gmail.com
X-Received: from mr.google.com ([10.182.85.193])
        by 10.182.85.193 with SMTP id j1mr2044579obz.52.1397134894524 (num_hops = 1);
        Thu, 10 Apr 2014 06:01:34 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=mime-version:in-reply-to:references:date:message-id:subject:from:to
         :content-type;
        bh=AlzfkVl01xnm/EQDtBrZZFnHBIcHZDGF/aR4YSGVfY4=;
        b=OJsmgiod6XfKMcQ1gBRwPZLVL0CQzwn4XtN3ql7duKm+AyXHuH2VF5fWtRmih1Y09u
         07iFm1szomTxaU0x6fx+R+70hFBNPscG1Js4rwkX9xT115V9B4bFMFLLArZfC7j5B8Vt
         Oxl2pz99tvijQhPYYsuf9qveGnqFuHQfJnDSOTKXdPUl/KdzYbqrCGe5w/Pyx/7E1x0r
         QcB2kL58ITCKud/nQJUU9uhIB5A8EqnOxMKDioG810tqeraPPDIPuLbMYe0FnnN248g+
         /4lgfRKZqSpyinPVNxm/iY3OKV5vo3RntvilpdS1AUxmSr9CKNNLnW+bOYgOpQnAn9xX
         Bnqw==
MIME-Version: 1.0
X-Received: by 10.182.85.193 with SMTP id j1mr2044579obz.52.1397134894520;
 Thu, 10 Apr 2014 06:01:34 -0700 (PDT)
Received: by 10.76.84.161 with HTTP; Thu, 10 Apr 2014 06:01:34 -0700 (PDT)
In-Reply-To: <5345E65D.30308@gmail.com>
References: <52C1DD3D.2040207@gmail.com>
	<CAOBF0rKKCwEucLmJMQoO8TKshYTgs1SwS1tO9hK1dktDsDWr7w@mail.gmail.com>
	<52D032AC.2080702@gmail.com>
	<CAOBF0r+yJu1x=O3bJgeEaj5uvVMNmdTgW-x6mDqg6DpYz_NabQ@mail.gmail.com>
	<5320FFC5.4050208@gmail.com>
	<CAOBF0rLM4-8OASA2vpoyvSH8LWdJTOeHfEzVsbd4Egs+-v7FWQ@mail.gmail.com>
	<5345E65D.30308@gmail.com>
Date: Thu, 10 Apr 2014 09:01:34 -0400
Message-ID: <CAOBF0rKm+zztupux6RWEx1t+eUzFybTif7kOKJHbDwm6ismXXw@mail.gmail.com>
Subject: Re: Calvin
From: Alexander Thomson <alexander.thomson@gmail.com>
To: Joel VanderWerf <joelvanderwerf@gmail.com>
Content-Type: multipart/alternative; boundary=089e01229a12175f0c04f6afd143

--089e01229a12175f0c04f6afd143
Content-Type: text/plain; charset=UTF-8

On Wed, Apr 9, 2014 at 8:31 PM, Joel VanderWerf <joelvanderwerf@gmail.com>wrote:

>
> Alex,
>
> I'm trying to sum up the difference between Calvin's commit agreement
> protocol and 2PC:
>
> Without determinism, commit agreement is an operational decision. Each
> node has its own view of the database state, possibly differing from the
> view at any other node, even if they replicate the same partitions. A
> node's agreement means that it is capable of proceeding with the
> transaction, if the coordinator decides to do so. When the coordinator
> receives agreement from all nodes, it instructs them to commit.
>

Correct. To be a bit more precise, a node's "agreement" in the context of
2PC is its ack of the leader's prepare message; this specifically means
that the effects of the transaction (but not the commit decision) are
durably written to the node's write-ahead log. But there are two dimensions
of distributed agreement: 2PC across all partitions participating in a
transaction, and a replication protocol across all copies of each
partition. According to the OSDI paper, for example, Spanner replicates
each node's write-ahead log via Paxos. This means that each 2PC participant
actually has to forge a Paxos concensus before even acking the prepare
message (and then again when the leader sends the commit instruction).


> With determinism, commit agreement is a logical predicate. A node's
> agreement is a function of its own view of the database state and, for each
> non-local partition, of read-results from just one node that replicates the
> partition. The node commits if and only if the predicate evaluates to true.


Correct.


> No global decision is required.
>

All nodes have to see the same sequence of transaction requests, which DOES
actually require a global decision---it's just a much less disruptive
decision to make, since choosing the request sequence can be done in bulk
in advance of execution rather than on a per-transaction basis at commit
time while holding locks.


> This difference has consequences in terms of latency, message topology,
> effect of node failure, replication, and so on. I'm not trying to gloss
> over those aspects of your papers (nor the possible optimizations you
> mentioned), but rather trying to be pithy (without being wrong or
> misleading!), for the sake of my upcoming talk about Calvin[1].
>
> Btw, you may be interested that the Fauna DB team[2] is looking at
> implementing Calvin-style transactions. The company was founded by Evan
> Weaver, formerly the architect of Twitter, known for moving from Rails to
> Scala to combat the fail whale.
>
> I hadn't heard of Fauna until a few days ago, when Evan contacted me,
> because of my Tupelo project and general interest in distributed
> transactions. He and I are meeting in Berkeley on Friday. I'd be happy to
> convey any comments or questions from you.
>

I hadn't heard of it either. I'll look over it.


> Joel
>
> ----
>
> [1] http://www.meetup.com/papers-we-love-too/events/171291972.
>   For the talk, I'm working on an executable model of Calvin (called
> "Spinoza"!), which models all concurrency and networking inside of a single
> process, with the storage model abstracted away. I can use this to explain
> how the commit protocol works, the tradeoffs in latency and availability,
> effects of failures, etc. Far from a TLA+ model, it's just for expository
> purposes.
>
> [2] https://fauna.org/developers/overview
>
>
>
> On 03/12/2014 10:45 PM, Alexander Thomson wrote:
>
>> On Wed, Mar 12, 2014 at 8:45 PM, Joel VanderWerf
>> <joelvanderwerf@gmail.com <mailto:joelvanderwerf@gmail.com>> wrote:
>>
> ...
>
>      Maybe this sentence from the 2012 paper, page 3, is the answer:
>>
>>         Rather, each node involved in a transaction waits for a one-way
>>         message from each node that could potentially deterministically
>>         abort
>>         the transaction, and only commits once it receives these messages.
>>
>>
>>     Doesn't this start to resemble 2PC? And also expose a vulnerability
>>     to network/node failures? (I guess the vulnerability is no worse
>>     than anything else, since a node only needs to receive 1 of n
>>     messages from n identical replicas.)
>>
>>
>> It resembles 2PC only in that both involve require some messaging
>> between partitions---its purpose and mechanics are different. There is
>> no way to implement a distributed database system without coordination
>> between machines; the best you can do is minimize the coordination and
>> move it out of critical sections when possible.
>>
>> In Calvin, as long as you can append to the log (sequencer) and there's
>> a scheduler alive for each partition at at least one replica, you can
>> make progress. Note that this actually is worse than in nondeterministic
>> systems, where all replicas of a partition can die and you can still
>> make progress on transactions that don't touch any data on that partition.
>>
>
>
>

--089e01229a12175f0c04f6afd143
Content-Type: text/html; charset=UTF-8
Content-Transfer-Encoding: quoted-printable

<div dir=3D"ltr"><div class=3D"gmail_extra"><div class=3D"gmail_quote">On W=
ed, Apr 9, 2014 at 8:31 PM, Joel VanderWerf <span dir=3D"ltr">&lt;<a href=
=3D"mailto:joelvanderwerf@gmail.com" target=3D"_blank">joelvanderwerf@gmail=
.com</a>&gt;</span> wrote:<br>
<blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;p=
adding-left:1ex"><br>
Alex,<br>
<br>
I&#39;m trying to sum up the difference between Calvin&#39;s commit agreeme=
nt protocol and 2PC:<br>
<br>
Without determinism, commit agreement is an operational decision. Each node=
 has its own view of the database state, possibly differing from the view a=
t any other node, even if they replicate the same partitions. A node&#39;s =
agreement means that it is capable of proceeding with the transaction, if t=
he coordinator decides to do so. When the coordinator receives agreement fr=
om all nodes, it instructs them to commit.<br>
</blockquote><div><br></div><div>Correct. To be a bit more precise, a node&=
#39;s &quot;agreement&quot; in the context of 2PC is its ack of the leader&=
#39;s prepare message; this specifically means that the effects of the tran=
saction (but not the commit decision) are durably written to the node&#39;s=
 write-ahead log. But there are two dimensions of distributed agreement: 2P=
C across all partitions participating in a transaction, and a replication p=
rotocol across all copies of each partition. According to the OSDI paper, f=
or example, Spanner replicates each node&#39;s write-ahead log via Paxos. T=
his means that each 2PC participant actually has to forge a Paxos concensus=
 before even acking the prepare message (and then again when the leader sen=
ds the commit instruction).</div>
<div><br></div><blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0p=
x 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-lef=
t-style:solid;padding-left:1ex">
<br>
With determinism, commit agreement is a logical predicate. A node&#39;s agr=
eement is a function of its own view of the database state and, for each no=
n-local partition, of read-results from just one node that replicates the p=
artition. The node commits if and only if the predicate evaluates to true.<=
/blockquote>
<div><br></div><div>Correct.</div><div>=C2=A0</div><blockquote class=3D"gma=
il_quote" style=3D"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-le=
ft-color:rgb(204,204,204);border-left-style:solid;padding-left:1ex">No glob=
al decision is required.<br>
</blockquote><div><br></div><div>All nodes have to see the same sequence of=
 transaction requests, which DOES actually require a global decision---it&#=
39;s just a much less disruptive decision to make, since choosing the reque=
st sequence can be done in bulk in advance of execution rather than on a pe=
r-transaction basis at commit time while holding locks.</div>
<div><br></div><blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0p=
x 0.8ex;border-left-width:1px;border-left-color:rgb(204,204,204);border-lef=
t-style:solid;padding-left:1ex">
<br>
This difference has consequences in terms of latency, message topology, eff=
ect of node failure, replication, and so on. I&#39;m not trying to gloss ov=
er those aspects of your papers (nor the possible optimizations you mention=
ed), but rather trying to be pithy (without being wrong or misleading!), fo=
r the sake of my upcoming talk about Calvin[1].<br>

<br>
Btw, you may be interested that the Fauna DB team[2] is looking at implemen=
ting Calvin-style transactions. The company was founded by Evan Weaver, for=
merly the architect of Twitter, known for moving from Rails to Scala to com=
bat the fail whale.<br>

<br>
I hadn&#39;t heard of Fauna until a few days ago, when Evan contacted me, b=
ecause of my Tupelo project and general interest in distributed transaction=
s. He and I are meeting in Berkeley on Friday. I&#39;d be happy to convey a=
ny comments or questions from you.<br>
</blockquote><div><br></div><div>I hadn&#39;t heard of it either. I&#39;ll =
look over it.</div><div><br></div><blockquote class=3D"gmail_quote" style=
=3D"margin:0px 0px 0px 0.8ex;border-left-width:1px;border-left-color:rgb(20=
4,204,204);border-left-style:solid;padding-left:1ex">

<br>
Joel<br>
<br>
----<br>
<br>
[1] <a href=3D"http://www.meetup.com/papers-we-love-too/events/171291972" t=
arget=3D"_blank">http://www.meetup.com/papers-<u></u>we-love-too/events/171=
291972</a>.<br>
=C2=A0 For the talk, I&#39;m working on an executable model of Calvin (call=
ed &quot;Spinoza&quot;!), which models all concurrency and networking insid=
e of a single process, with the storage model abstracted away. I can use th=
is to explain how the commit protocol works, the tradeoffs in latency and a=
vailability, effects of failures, etc. Far from a TLA+ model, it&#39;s just=
 for expository purposes.<br>

<br>
[2] <a href=3D"https://fauna.org/developers/overview" target=3D"_blank">htt=
ps://fauna.org/developers/<u></u>overview</a><div class=3D""><br>
<br>
<br>
On 03/12/2014 10:45 PM, Alexander Thomson wrote:<br>
</div><blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;b=
order-left-width:1px;border-left-color:rgb(204,204,204);border-left-style:s=
olid;padding-left:1ex"><div class=3D"">
On Wed, Mar 12, 2014 at 8:45 PM, Joel VanderWerf<br></div>
&lt;<a href=3D"mailto:joelvanderwerf@gmail.com" target=3D"_blank">joelvande=
rwerf@gmail.com</a> &lt;mailto:<a href=3D"mailto:joelvanderwerf@gmail.com" =
target=3D"_blank">joelvanderwerf@gmail.<u></u>com</a>&gt;&gt; wrote:<br>
</blockquote>
...<div class=3D""><div class=3D"h5"><br>
<blockquote class=3D"gmail_quote" style=3D"margin:0px 0px 0px 0.8ex;border-=
left-width:1px;border-left-color:rgb(204,204,204);border-left-style:solid;p=
adding-left:1ex">
=C2=A0 =C2=A0 Maybe this sentence from the 2012 paper, page 3, is the answe=
r:<br>
<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 Rather, each node involved in a transaction wai=
ts for a one-way<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 message from each node that could potentially d=
eterministically<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 abort<br>
=C2=A0 =C2=A0 =C2=A0 =C2=A0 the transaction, and only commits once it recei=
ves these messages.<br>
<br>
<br>
=C2=A0 =C2=A0 Doesn&#39;t this start to resemble 2PC? And also expose a vul=
nerability<br>
=C2=A0 =C2=A0 to network/node failures? (I guess the vulnerability is no wo=
rse<br>
=C2=A0 =C2=A0 than anything else, since a node only needs to receive 1 of n=
<br>
=C2=A0 =C2=A0 messages from n identical replicas.)<br>
<br>
<br>
It resembles 2PC only in that both involve require some messaging<br>
between partitions---its purpose and mechanics are different. There is<br>
no way to implement a distributed database system without coordination<br>
between machines; the best you can do is minimize the coordination and<br>
move it out of critical sections when possible.<br>
<br>
In Calvin, as long as you can append to the log (sequencer) and there&#39;s=
<br>
a scheduler alive for each partition at at least one replica, you can<br>
make progress. Note that this actually is worse than in nondeterministic<br=
>
systems, where all replicas of a partition can die and you can still<br>
make progress on transactions that don&#39;t touch any data on that partiti=
on.<br>
</blockquote>
<br>
<br>
</div></div></blockquote></div><br></div></div>

--089e01229a12175f0c04f6afd143--
